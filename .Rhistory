group_by(set_id, scientificName_Nom_scientifique) %>%
summarise(total_count = sum(total_count, na.rm = TRUE), .groups = "drop")
# Step 2: Define Shannon Index calculation function
shannon_index <- function(counts) {
total <- sum(counts)
p_i <- counts / total
-sum(p_i * log(p_i), na.rm = TRUE)
}
# Step 3: Apply Shannon Index per group (set_id)
shannon_indices <- species_counts %>%
group_by(set_id) %>%
summarise(shannon_index = shannon_index(total_count), .groups = "drop")
# Step 4: Merge Shannon index back to original df1
df_with_shannon <- df1 %>%
left_join(shannon_indices, by = c("set_id"))
names(df1_avg)
my_colors <- c(
"1" = "#e41a1c",  # red
"2" = "#377eb8",  # blue
"3" = "#4daf4a",  # green
"4" = "#984ea3",  # purple
"5" = "#ff7f00",  # orange
"6" = "#ffff33"   # yellow
)
# Plot with custom colors
ggplot(df1_avg, aes(x = lon, y = lat, color = Cluster_drop)) +
geom_point(size = 3, shape = 21, stroke = 1) +
scale_color_manual(values = my_colors) +
labs(
title = "K-Means Clustering of Stations Based on Location",
x = "Longitude",
y = "Latitude",
color = "Cluster"
) +
theme_minimal() +
theme(legend.position = "right") +
guides(color = guide_legend(title.position = "top"))
library(ggplot2)
library(readr)
df1 <- read.csv("./data/Musquash_MPA_Benthos_Infauna.csv", encoding = 'latin1')
df2 <- read.csv("./data/Musquash_MPA_Sediment_Grain_Size.csv", encoding = 'latin1')
df3 <- read.csv("./data/Musquash_MPA_Sediment_Loss_Ignition.csv", encoding = 'latin1')
df4 <- read.csv("./data/Musquash_MPA_Set_Data.csv", encoding = 'latin1')
library(dplyr)
# check is set_id unique to strata
all_same <- df1 %>%
group_by(set_id) %>%
summarise(n_strata = n_distinct(strata_strate)) %>%
summarise(all_unique = all(n_strata == 1))
print(all_same)
# Step 1: Group data by set_id, and scientific name, and sum total_count
species_counts <- df1 %>%
group_by(set_id, scientificName_Nom_scientifique) %>%
summarise(total_count = sum(total_count, na.rm = TRUE), .groups = "drop")
# Step 2: Define Shannon Index calculation function
shannon_index <- function(counts) {
total <- sum(counts)
p_i <- counts / total
-sum(p_i * log(p_i), na.rm = TRUE)
}
# Step 3: Apply Shannon Index per group (set_id)
shannon_indices <- species_counts %>%
group_by(set_id) %>%
summarise(shannon_index = shannon_index(total_count), .groups = "drop")
# Step 4: Merge Shannon index back to original df1
df_with_shannon <- df1 %>%
left_join(shannon_indices, by = c("set_id"))
# Step 5: Merge species richness with Shannon index
species_richness <- df1 %>%
group_by(set_id) %>%
summarise(species_richness = n_distinct(scientificName_Nom_scientifique), .groups = "drop")
df_with_richness <- df_with_shannon %>%
left_join(species_richness, by = c("set_id"))
df_with_richness
df_with_richness <- df_with_richness %>%
filter(species_richness != 1)
# Step 1: Separate numeric and categorical columns
num_cols <- df_with_richness %>% select(where(is.numeric)) %>% select (-total_count)%>%colnames()
cat_cols <- df_with_richness %>% select(where(~ is.character(.) || is.factor(.))) %>% colnames()
# Step 2: Define grouping column
group_cols <- "set_id"
# Step 3: Group and summarise
df1_avg <- df_with_richness %>%
group_by(across(all_of(group_cols))) %>%
summarise(
# Keep the first value for each categorical column
across(all_of(setdiff(cat_cols, group_cols)), ~ first(.x), .names = "{.col}"),
# Average the numeric columns
across(all_of(setdiff(num_cols, group_cols)), ~ first(.x), .names = "{.col}"),
across(all_of(c("total_count")), ~ sum(.x, na.rm = TRUE), .names = "{.col}"), ##should get the same values as mean.
.groups = "drop"
)
df1_avg
# For df2
df2_avg <- df2 %>%
select(-replicate_réplicat) %>%
group_by(set_id) %>%
summarise(across(where(is.numeric), \(x) mean(x, na.rm = TRUE)), .groups = "drop")
# For df3
df3_avg <- df3 %>%
select(-replicate_réplicat) %>%
group_by(set_id) %>%
summarise(across(where(is.numeric), \(x) mean(x, na.rm = TRUE)), .groups = "drop")
df2_avg
# Assuming group_cols has already been defined, e.g.:
group_cols <- "set_id"
# Get numeric column names in df4
num_cols <- df4 %>% select(where(is.numeric)) %>% colnames()
# Calculate mean of all numeric columns except the group column
df4_avg <- df4 %>%
group_by(across(all_of(group_cols))) %>%
summarise(across(
all_of(setdiff(num_cols, group_cols)),
\(x) mean(x, na.rm = TRUE)
), .groups = "drop")
df4_avg
library(ggplot2)
set.seed(42)
# distionct lat and lon
distinct_locations <- df1 %>%
select(lon, lat) %>%
distinct()
# KMeans clustering on these distinct locations
kmeans_result <- kmeans(distinct_locations[, c("lon", "lat")], centers = 6)
cluster_df <- distinct_locations %>%
mutate(Cluster_drop = as.factor(kmeans_result$cluster))
write.csv(cluster_df, "6location_clusters.csv", row.names = FALSE)
df1_avg <- df1_avg %>%
left_join(cluster_df, by = c("lon", "lat"))
names(df1_avg)
my_colors <- c(
"1" = "#e41a1c",  # red
"2" = "#377eb8",  # blue
"3" = "#4daf4a",  # green
"4" = "#984ea3",  # purple
"5" = "#ff7f00",  # orange
"6" = "#ffff33"   # yellow
)
# Plot with custom colors
ggplot(df1_avg, aes(x = lon, y = lat, color = Cluster_drop)) +
geom_point(size = 3, shape = 21, stroke = 1) +
scale_color_manual(values = my_colors) +
labs(
title = "K-Means Clustering of Stations Based on Location",
x = "Longitude",
y = "Latitude",
color = "Cluster"
) +
theme_minimal() +
theme(legend.position = "right") +
guides(color = guide_legend(title.position = "top"))
df2_avg <- df2_avg %>%
mutate(
wet_weight = gross_wet_wt_g - cont_wt_g,
dry_weight = gross_dry_wt_g - cont_wt_g,
water_content_ratio = (wet_weight - dry_weight) / wet_weight
)
df2_avg <- df2_avg %>%
mutate(
total_fraction_weight = net_dry_250um_g + net_dry_125um_g + net_dry_64um_g + silt_frac_g,
sand_pct = (net_dry_250um_g + net_dry_125um_g) / total_fraction_weight,
fine_sand_pct = net_dry_64um_g / total_fraction_weight,
silt_clay_pct = silt_frac_g / total_fraction_weight
)
df3_avg <- df3_avg %>%
mutate(
air_dry_wt = air_cont_g - cont_g,
oven_dry_wt = oven_cont_g - cont_g,
loss_ash1 = ash_1_g,
loss_ash2 = ash_1_g - ash_2_g,
perc_loss_ash_1_calc = (loss_ash1 / oven_dry_wt) * 100,
perc_loss_ash_2_calc = (loss_ash2 / ash_1_g) * 100
)
df3_avg
# Required columns for each dataset
# df1: Benthic Infauna — keep ID + ecological summary info
cols_df1 <- c(
"set_id", "station", "strata_strate", "season_saison",
"total_count", "tot_wt_g", "shannon_index", "species_richness"
)
# df2: Sediment Grain Size — keep values needed for calculations or summaries
cols_df2 <- c(
"set_id",
"wet_weight", "dry_weight", "water_content_ratio",
"sand_pct", "fine_sand_pct", "silt_clay_pct"
)
# df3: Organic Matter — key weights and loss percentages
cols_df3 <- c(
"set_id",
"air_dry_wt", "oven_dry_wt", "loss_ash1",
"loss_ash2", "tot_perc_loss__"
)
# df4: Basic depth info
cols_df4 <- c("set_id", "depth_m_profondeur_m")
df1_avg <- df1_avg %>% select(all_of(cols_df1))
df2_avg <- df2_avg %>% select(all_of(cols_df2))
df3_avg <- df3_avg %>% select(all_of(cols_df3))
df4_avg <- df4_avg %>% select(all_of(cols_df4))
df_merged <- df1_avg %>%
left_join(df2_avg, by = "set_id") %>%
left_join(df3_avg, by = "set_id") %>%
left_join(df4_avg, by = "set_id")
df_merged
write.csv(df_merged, "./data/MPA_merged.csv", row.names = FALSE)
df4$depth_m_profondeur_m
write.csv(df_merged, "./data/MPA_merged.csv", row.names = FALSE)
library(readr)
# Read the CSV file
data <- read.csv("./data/MPA_merged.csv")
head(data)
library(dplyr)
library(lme4)
library(caret)
library(ggplot2)
library(ggplot2)
library(reshape2)
library(corrplot)
cor_data <- na.omit(data[, num_cols])
num_cols <- c(
# Sediment Moisture / Grain Size
"wet_weight",           # Wet sediment weight (excluding container)
"dry_weight",           # Dry sediment weight (excluding container)
"water_content_ratio",  # Ratio of water content in sample
# Particle Size Distribution
"sand_pct",             # % of coarse sand particles
"fine_sand_pct",        # % of fine sand (64µm) particles
"silt_clay_pct",        # % of silt/clay particles (<64µm)
# Organic Matter (Loss on Ignition)
"air_dry_wt",           # Weight after air drying
"oven_dry_wt",          # Weight after oven drying
"loss_ash1",            # Weight loss after 475°C burn (organic matter)
"loss_ash2",            # Weight loss after 950°C burn (recalcitrant organics)
"tot_perc_loss__",      # Total % loss (combined phases)
# Depth
"depth_m_profondeur_m",
# sample weight
"tot_wt_g"
)
library(ggplot2)
library(reshape2)
library(corrplot)
cor_data <- na.omit(data[, num_cols])
cor_matrix <- cor(cor_data)
melted_cor <- melt(cor_matrix)
ggplot(melted_cor, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name = "Correlation") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 10, hjust = 1)) +
coord_fixed() +
labs(title = "Correlation Heatmap of Numerical Variables",
x = "", y = "")
set.seed(123)
train_indices <- sample(1:nrow(data), size = 0.8 * nrow(data))
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]
nrow(train_data)
nrow(test_data)
train_data <- train_data %>%
mutate(across(where(is.numeric), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# --- Sediment Moisture / Grain Size ---
moisture_train <- train_data %>%
select(wet_weight, dry_weight, water_content_ratio)
moisture_pca <- prcomp(moisture_train, center = TRUE, scale. = TRUE)
moisture_vars <- train_data %>%
select(wet_weight, dry_weight, water_content_ratio)
moisture_pca <- prcomp(moisture_vars, center = TRUE, scale. = TRUE)
# --- Particle Size Distribution ---
particle_vars <- train_data %>%
select(sand_pct, fine_sand_pct, silt_clay_pct)
particle_pca <- prcomp(particle_vars, center = TRUE, scale. = TRUE)
# --- Organic Matter (LOI) ---
organic_vars <- train_data %>%
select(air_dry_wt, oven_dry_wt, loss_ash1, loss_ash2, tot_perc_loss__)
organic_pca <- prcomp(organic_vars, center = TRUE, scale. = TRUE)
summary(moisture_pca)
summary(particle_pca)
summary(organic_pca)
# Fill missing value with mean
train_data_filled <- train_data %>%
mutate(across(all_of(num_cols), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# Fill in test set
test_data <- test_data %>%
mutate(across(all_of(num_cols), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
train_data_filled
# Remove outliers based on z-score
remove_outliers <- function(df, cols, threshold = 3) {
z_scores <- scale(df[, cols])
outlier_mask <- apply(abs(z_scores), 1, function(row) all(row < threshold))
df[outlier_mask, ]
}
train_data <- remove_outliers(train_data_filled, num_cols)
print(summary(train_data))
# only on numeric features
numeric_features <- num_cols
# Formula
formula <- as.formula(paste("shannon_index ~", paste(numeric_features, collapse = " + ")))
# fit
lm_full <- lm(formula, data = train_data)
# AIC stepwise
lm_selected <- step(lm_full, direction = "backward")
summary(lm_selected)
data<-data%>%mutate(year = substr(set_id, 1, 4))
data
data$silt_clay_pct
scale(data$silt_clay_pct)
scale(data$silt_clay_pct)
data$silt_clay_pct
data$silt_clay_pct
names(data)
data<-data%>%mutate(year = substr(set_id, 1, 4))
data$season <- relevel(factor(data$season), ref = "Winter")
data$strata <-as.factor(data$strata)
data$year <-as.factor(data$year)
data$n_scale <-scale(data$total_count)
data_rm <- data%>%
rename(tot_perc_loss = tot_perc_loss__)
metrics <- c("shannon")
lm_mod <- list()
mod <- list()
for (m in metrics) {
cat("\n--- Metric:", m, "---\n")
formula_lmer <- as.formula(paste0(m, " ~ season + year + (1|strata) + silt_clay_pct+ tot_perc_loss + n_scale"))
formula_lm   <- as.formula(paste0(m, " ~ season + year + strata + silt_clay_pct + tot_perc_loss + n_scale "))
lm_mod[[m]] <- lm(formula_lm, data = data)
mod[[m]]    <- lmer(formula_lmer, data = data)
cat("\nLinear model ANOVA for", m, ":\n")
print(summary(lm_mod[[m]]))
print(anova(lm_mod[[m]]))
cat("\nMixed model ANOVA for", m, ":\n")
print(summary(mod[[m]]))
print(anova(mod[[m]]))
lm_mod[[m]]|>plot()
# Residual diagnostics
par(mfrow = c(1, 2))
plot(fitted(mod[[m]]), resid(mod[[m]]),
main = paste("Residuals vs Fitted:", m),
xlab = "Fitted", ylab = "Residuals")
abline(h = 0, col = "red")
qqnorm(resid(mod[[m]]), main = paste("QQ-Plot:", m))
qqline(resid(mod[[m]]))
par(mfrow = c(1, 1))
}
metrics <- c("shannon_index")
lm_mod <- list()
mod <- list()
for (m in metrics) {
cat("\n--- Metric:", m, "---\n")
formula_lmer <- as.formula(paste0(m, " ~ season + year + (1|strata) + silt_clay_pct+ tot_perc_loss + n_scale"))
formula_lm   <- as.formula(paste0(m, " ~ season + year + strata + silt_clay_pct + tot_perc_loss + n_scale "))
lm_mod[[m]] <- lm(formula_lm, data = data)
mod[[m]]    <- lmer(formula_lmer, data = data)
cat("\nLinear model ANOVA for", m, ":\n")
print(summary(lm_mod[[m]]))
print(anova(lm_mod[[m]]))
cat("\nMixed model ANOVA for", m, ":\n")
print(summary(mod[[m]]))
print(anova(mod[[m]]))
lm_mod[[m]]|>plot()
# Residual diagnostics
par(mfrow = c(1, 2))
plot(fitted(mod[[m]]), resid(mod[[m]]),
main = paste("Residuals vs Fitted:", m),
xlab = "Fitted", ylab = "Residuals")
abline(h = 0, col = "red")
qqnorm(resid(mod[[m]]), main = paste("QQ-Plot:", m))
qqline(resid(mod[[m]]))
par(mfrow = c(1, 1))
}
metrics <- c("shannon_index")
lm_mod <- list()
mod <- list()
for (m in metrics) {
cat("\n--- Metric:", m, "---\n")
formula_lmer <- as.formula(paste0(m, " ~ season + year + (1|strata) + silt_clay_pct+ tot_perc_loss + n_scale"))
formula_lm   <- as.formula(paste0(m, " ~ season + year + strata + silt_clay_pct + tot_perc_loss + n_scale "))
lm_mod[[m]] <- lm(formula_lm, data = data_rm)
mod[[m]]    <- lmer(formula_lmer, data = data_rm)
cat("\nLinear model ANOVA for", m, ":\n")
print(summary(lm_mod[[m]]))
print(anova(lm_mod[[m]]))
cat("\nMixed model ANOVA for", m, ":\n")
print(summary(mod[[m]]))
print(anova(mod[[m]]))
lm_mod[[m]]|>plot()
# Residual diagnostics
par(mfrow = c(1, 2))
plot(fitted(mod[[m]]), resid(mod[[m]]),
main = paste("Residuals vs Fitted:", m),
xlab = "Fitted", ylab = "Residuals")
abline(h = 0, col = "red")
qqnorm(resid(mod[[m]]), main = paste("QQ-Plot:", m))
qqline(resid(mod[[m]]))
par(mfrow = c(1, 1))
}
print(summary(lm_mod[[m]]))
print(anova(lm_mod[[m]]))
ggplot(data, aes(x = season, y = shannon)) +
geom_boxplot(fill = "lightblue", color = "black") +
labs(title = "Shannon Diversity by Season", x = "Season", y = "Shannon Index") +
theme_minimal()
metrics <- c("shannon_index")  ## remove simpson, richness, s_obs
lm_mod <- list()
mod <- list()
for (m in metrics) {
cat("\n--- Metric:", m, "---\n")
formula_lmer <- as.formula(paste0(m, " ~ season + year + (1|strata) + silt_clay_pct+ tot_perc_loss + n_scale"))
formula_lm   <- as.formula(paste0(m, " ~ season + year + strata + silt_clay_pct + tot_perc_loss + n_scale "))
lm_mod[[m]] <- lm(formula_lm, data = data_rm)
mod[[m]]    <- lmer(formula_lmer, data = data_rm)
cat("\nLinear model ANOVA for", m, ":\n")
print(summary(lm_mod[[m]]))
print(anova(lm_mod[[m]]))
cat("\nMixed model ANOVA for", m, ":\n")
print(summary(mod[[m]]))
print(anova(mod[[m]]))
lm_mod[[m]]|>plot()
# Residual diagnostics
par(mfrow = c(1, 2))
plot(fitted(mod[[m]]), resid(mod[[m]]),
main = paste("Residuals vs Fitted:", m),
xlab = "Fitted", ylab = "Residuals")
abline(h = 0, col = "red")
qqnorm(resid(mod[[m]]), main = paste("QQ-Plot:", m))
qqline(resid(mod[[m]]))
par(mfrow = c(1, 1))
}
plot(fitted(lm_mod[[m]]), lm_mod[[m]]$model[[m]],
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lm):", m))
abline(0, 1, col = "red", lty = 2)
plot(fitted(mod[[m]]), mod[[m]]@frame[[m]],
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lmer):", m))
abline(0, 1, col = "blue", lty = 2)
par(mfrow = c(1, 2))
plot(fitted(mod[[m]]), resid(mod[[m]]),
main = paste("Residuals vs Fitted:", m),
xlab = "Fitted", ylab = "Residuals")
abline(h = 0, col = "red")
qqnorm(resid(mod[[m]]), main = paste("QQ-Plot:", m))
qqline(resid(mod[[m]]))
par(mfrow = c(1, 1))
plot(fitted(lm_mod[[m]]), lm_mod[[m]]$model[[m]],
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lm):", m))
abline(0, 1, col = "red", lty = 2)
plot(fitted(mod[[m]]), mod[[m]]@frame[[m]],
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lmer):", m))
abline(0, 1, col = "blue", lty = 2)
y_obs <- model.response(model.frame(mod[[m]]))
x_fit <- fitted(mod[[m]])
plot(x_fit, y_obs,
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lmer):", m),
pch = 19)
abline(0, 1, col = "blue", lty = 2)
ggplot(data, aes(x = season, y = shannon)) +
geom_boxplot(fill = "lightblue", color = "black") +
labs(title = "Shannon Diversity by Season", x = "Season", y = "Shannon Index") +
theme_minimal()
ggplot(data_rm, aes(x = season, y = shannon_index)) +
geom_boxplot(fill = "lightblue", color = "black") +
labs(title = "Shannon Diversity by Season", x = "Season", y = "Shannon Index") +
theme_minimal()
#compare mixed model to linear model
metrics <- c("shannon_index")  ## remove simpson, richness, s_obs
lm_mod <- list()
mod <- list()
for (m in metrics) {
cat("\n--- Metric:", m, "---\n")
formula_lmer <- as.formula(paste0(m, " ~ season + year + (1|strata) + silt_clay_pct+ tot_perc_loss + n_scale"))
formula_lm   <- as.formula(paste0(m, " ~ season + year + strata + silt_clay_pct + tot_perc_loss + n_scale "))
lm_mod[[m]] <- lm(formula_lm, data = data_rm)
mod[[m]]    <- lmer(formula_lmer, data = data_rm)
cat("\nLinear model ANOVA for", m, ":\n")
print(summary(lm_mod[[m]]))
print(anova(lm_mod[[m]]))
cat("\nMixed model ANOVA for", m, ":\n")
print(summary(mod[[m]]))
print(anova(mod[[m]]))
lm_mod[[m]]|>plot()
# Residual diagnostics
par(mfrow = c(1, 2))
plot(fitted(mod[[m]]), resid(mod[[m]]),
main = paste("Residuals vs Fitted:", m),
xlab = "Fitted", ylab = "Residuals")
abline(h = 0, col = "red")
qqnorm(resid(mod[[m]]), main = paste("QQ-Plot:", m))
qqline(resid(mod[[m]]))
par(mfrow = c(1, 1))
plot(fitted(lm_mod[[m]]), lm_mod[[m]]$model[[m]],
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lm):", m))
abline(0, 1, col = "red", lty = 2)
plot(fitted(mod[[m]]), mod[[m]]@frame[[m]],
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lmer):", m))
abline(0, 1, col = "blue", lty = 2)
}
y_obs <- model.response(model.frame(mod[[m]]))
x_fit <- fitted(mod[[m]])
plot(x_fit, y_obs,
xlab = "Fitted values", ylab = "Observed",
main = paste("Observed vs Fitted (lmer):", m),
pch = 19)
abline(0, 1, col = "blue", lty = 2)
dfdfgsdf
